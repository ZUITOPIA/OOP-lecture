# 용어 정리 첫 번째 과제

> 1. JVM
>     - Java Virtual Machine의 줄임말
>     - OS에 종속적이지 않은 자바를 인식, 실행하기 위한 가상 기계(컴퓨터)
>     - Java 소스코드는 CPU가 인식하지 못 하므로 기계어로 컴파일을 해주어야 하는데 JVM을 거쳐 OS에 도달하기 때문에 (OS가 인식할 수 있는 기계어로 바로 컴파일 되는 것이 아닌) Java compiler가 .java 파일을 JVM이 인식할 수 있는 Java byte code(.class)로 변환함, 그 이후 JVM이 OS가 byte code를 이해할 수 있도록 해석해 줌
>     - Java compiler : JDK 설치하면 bin에 존재하는 Javac.exe (JDK 내에 java compiler가 포함)

> 2. OOP
>     - Object Oriented Programming
>     - 객체들의 유기적인 관계를 통해서 프로세스가 진행됨
>     - 애플리케이션을 구성하는 요소들을 객체로 바라보고, 객체들을 유기적으로 연결하여 프로그래밍
>     - 특징 : 추상화, 캡슐화, 상속, 다형성
>     - 장점 : 코드 재사용성, 간편한 유지보수, 큰 규모의 프로그래밍에 유리
>     - 단점 : 비교적 느린 속도, 높은 설계역량 요구, 코드의 잠재적인 복잡성  
>       2-1. 추상화, 캡슐화, 상속, 다형성
>     - 추상화 (Abstraction)
>     - 캡슐화 (Encapsulation)
>     - 상속 (Inheritance)
>     - 다형성 (Polymorphism)

> 3.  Instance : 메모리 공간을 확보하는 기준
>     -   Main memory 에서 생성됨
>     -   class는 define만 되고 실행한 이후에 generate 되면서 instance가 만들어짐

> 4.  disk : 프로그램이 돌아가는 곳

> 5.  API : 가져와서 실행하고자 하는 함수의 이름, 정의
>     -   다른 사람의 Package를 Import 해서 사용하며, Package 안에 class가 있음
>     -   many classes and methods

> 6. Constructor : 객체가 처음 생성될 때 호출되어 멤버 변수를 초기화하고, 필요에 따라 자원을 할당하는 것

> 7. Interfaces (자세히 정의하기 과제)

> 8. Instance : 메모리 공간을 확보하는 기준
>     - Main memory 에서 생성됨
>
> -   class는 define만 되고 실행한 이후에 generate 되면서 instance가 만들어짐
> -   객체를 소프트웨어에 실체화 한 것, 실체화 된 instance 는 메모리에 할당됨
> -   OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 instance라 부름
>
> ##### Class vs Object
>
> -   Class : 설계도
> -   Object : 설계도로 구현한 모든 대상을 의미함
>
> ##### Object vs Instance
>
> -   Object : Class 타입으로 선언되었을 때
> -   Instance : 그 Object 가 메모리에 할당되어 실제 사용될 때
> -   Object 는 실체, Instance 는 관계에 초점을 맞춤
> -   Object 를 Class의 Instance 라고도 부름

> 9. Heap
>
> -   힙 메모리 영역
> -   참조형(Reference Type)의 데이터 타입을 갖는 Object(Instance), Array 등이 저장되는 영역
> -   변수(객체, 객체변수, 참조변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조 값(reference value, 해시코드 / 메모리에 저장된 주소를 연결해주는 값)을 new 연산자를 통해 return 받음
> -   실제 데이터를 갖고 있는 Heap 영역의 참조 값을 Stack 영역의 객체가 갖고 있음
> -   Return 받은 참조 값을 갖고 있는 객체를 통해서만 해당 instance 를 handle 할 수 있음
>     참고
> -   Heap 영역에 저장된 data가 더 이상 불필요하다면 메모리 관리를 위해 JVW(Java Virtual Machine)에 의해 알아서 해제 됨 => GC(Garbage collection)

> 10. Stack
>
> -   스택 메모리 영역
> -   Method 내에서 정의하는 기본 자료형(int, double, byte, long, boolean 등)에 해당되는 지역 변수(매개 변수 및 블럭문 내 변수 포함)의 데이터의 값이 저장되는 영역
> -   해당 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제됨
> -   LIFO(Last In First Out)의 구조
> -   변수에 새로운 데이터가 할당되면 이전 데이터는 지워짐

> 11. Segment
>
> ##### Text Segment or Code Segment (.code)
>
> -   CPU가 읽어 해설할 수 있는 기계어들이 위치하게 되는 영역
> -   작성한 메인 프로그램의 기계어 코드가 위치하는 영역
> -   실행 가능한 명령어(Instruction)이 포함된 오브젝트 파일 또는 메모리 공간을 할당 받은 프로그램 섹션 중 하나
> -   프로그램을 실행시킬 때 각각의 함수들이 변경되면 안 되기 때문에 Read-Only인 경우가 많음
> -   Heap과 Stack에 의해 메모리 공간이 덮어 씌워지지 않도록 일반적으로 Heap , Stack 메모리 공간 아래에 위치함
> -   프로세스가 종료될 때까지 유지되는 영역
> -   보통 첫번째로 실행 가능한 명령어는 segment의 맨 처음에 위치하며, OS는 프로그램 실행을 시작하기 위해 그 위치를 알고 있음
> -   Code Segment(CS) 레지스터는 Code Segment의 주소를 의미함
> -   코딩한 것을 실행시키면 CPU가 알아서 코드영역에 저장된 명령어들을 하나씩 가져가 처리하는 방식으로 프로그램을 실행함
>
> ##### Initialized Data Segment (.data)
>
> -   프로그램의 가상 주소 공간의 일부분
> -   초기화된 전역 변수와 Static 정적 변수를 포함함
> -   Initialized Read-Only Area vs Initial Read-Write Area
>
> ##### Initial Read-Write Area : 변수에 접근 가능, 값 변경 가능
>
> ##### Uninitialized Data Segment (.bss)
>
> -   초기화되지 않은 data segment => BSS Segment라 불림
> -   BSS란 Block Started by Symbol의 줄임말
> -   BSS Segment 의 data는 프로그램의 실행과 함께 커널(스타트업 코드)에 의해 0으로 초기화 됨
> -   초기화 되지 않은 데이터는 data segment 공간의 끝에서 시작되며 명시적인 초기화가 없는 모든 전역 변수와 Static 정적 변수를 포함함
>
> ##### Stack, Heap

### 객체와 관계 없이 프로그램을 위한 것들

> 12. Package
>
> -   자바에서 Package란 클래스들의 모음임
> -   패키지를 통해 편리하게 프로젝트를 관리할 수 있고, 내 코드들을 다른 라이브러리로부터, 혹은 다른 라이브러리들끼리 서로 구분할 수 있음
>     -> 클래스명의 고유성을 보장할 수 있음
> -   자바 라이브러리는 우리가 일반 폴더 구조에서 볼 수 있는 계층적 패키지 구조를 가지고 있음
>     -> 계층적 패키지 구조 : 상위 패키지에 하위패키지가 종속되는 형식
>     ( 모든 자바 패키지들은 가장 상위 패키지인 java와 javax 패키지에 종속되어 있음 )
> -   클래스나 인터페이스를 관련된 것 끼리 모음
> -   보통의 경우 package가 없는 class나 interface는 만들지 않음
> -   가장 기본이 되는 package
>     -   java.lang : import 하지 않아도 사용 가능
>     -   java.util : 자료구조 등 유용한 클래스들이 있음
>     -   java.io : 자바 입출력과 관련된 클래스들이 있음
>     -   java.sql : DB 프로그래밍과 관련된 클래스들이 있음

> 13. Import
>
> -   다른 패키지 안에 있는 클래스/메소드/변수를 사용할 때 사용하는 키워드 (매번 클래스의 이름 앞에 패키지 이름을 붙이지 않고도 파일의 앞머리에 Import라는 작업으로 패키지 이름을 매번 입력하는 단점을 없애줌)
> -   예외 : 다른 패키지 속의 클래스 명칭과 겹치면 이를 구분할 수 없기 때문에 클래스 충돌이 발생
>     -> 어떤 패키지의 클래스인지 명칭을 작성해 주어야 함

### 객체의 접근 기준

> 14. public
>
> -   외부 클래스가 자유롭게 사용할 수 있음

> 15. private
>
> -   외부에서 사용할 수 없음

> 16. protected
>
> -   같은 패키지 또는 자식 클래스에서 사용할 수 있음
>     위 세가지 접근 제한자가 적용되지 않으면 default 접근 제한을 가짐
>     -> default 접근 제한 : 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 함

### 객체의 구성

> 17. Class
>
> -   변수(데이터, 속성)와 메서드(행위)를 가지고 있는 집합
> -   객체를 생성하기 위한 틀
> -   Class 키워드로 정의하고 new 연산자를 통해 instance를 생성함
> -   자바는 클래스들의 모임으로 이뤄져 있음
> -   클래스에서 객체를 생성하는 과정을 인스턴스화라고 하며 생성된 객체를 인스턴스라고 함  
>     (1) 객체 변수 (Object Variable)
>
>     -   클래스 내부에서 선언된 변수
>
>     (2) 메서드
>
>     -   클래스 내부에 . 연산자를 이용하여 접근할 수 있음(객체 지향 프로그래밍에서는 캡슐화를 통한 정보 은닉을 기본원칙으로 삼기 때문에 직접적으로 객체 변수에 접근하도록 코드를 만들지는 않음, 그럴 때 사용하는 방법이 메서드를 이용하여 변수에 접근하는 것)

> 18. Interface
>
> -   자식 클래스가 여러 부모 클래스를 상속받을 수 있다면 다양한 동작을 수행할 수 있는 장점이 있겠지만, 클래스를 이용하여 다중상속을 할 경우 메소드 출처의 모호성 등 여러가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속을 지원하지 않음
> -   대신 Interface라는 것을 통해 다중상속과 비슷한 효과를 냄
> -   다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개역할을 담당하는 일종의 추상 클래스
> -   주의! 자바에서의 추상 클래스는 추상 메소드 뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있음. 하지만 Interface는 오로지 추상 메소드와 상수만을 포함할 수 있음
> -   클래스와 클래스 간의 관계를 인터페이스로 연결하면 클래스마다 독립적인 프로그래밍이 가능함

### 상속

> OOP의 특징  
> (1) 계층성(상속과 인터페이스)  
> (2) 다형성, 사용편의성(모듈화)  
> (3) 캡슐화, 정보은닉  
> (4) 자료 추상화(모델링)  
> (5) 동적 바인딩

> 19. Extends
>
> -   상속의 대표적인 형태
> -   부모에서 선언/정의를 모두 함, 자식은 부모의 메소드/변수를 그대로 사용할 수 있음 (오버라이딩 필요X)
> -   클래스 한 개만 상속받을 수 있음

> 20. Implements
>
> -   자바는 다중상속을 지원하지 않기 때문에, 부모 클래스가 두 개 이상 존재할 수 없으며 그리하여 implements가 등장하게 됨
> -   부모 객체는 선언만 하며 내용에 대한 정의는 반드시 자식에서 오버라이딩(재정의)해서 사용해야 함
> -   여러 개의 interfaces 상속받을 수 있음

> ##### 추가
>
> 21. Abstract
>
> -   Extends와 implements 혼합
> -   Extends하되 몇 개는 추상 메소드로 구현 되어 있음

### 상속의 제약 조건

> 22. Static
>
> -   Static 키워드를 통해 생성된 정적 멤버들은 Heap 영역이 아닌 Static 영역에 할당됨
> -   Static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있지만, GC(Garbage Collector)의 관리 영역 밖에 존재하기 때문에 Static 영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 종료됨 -> static을 남발하면 시스템 성능에 악영향을 줄 수 있음
> -   필드, 메소드 생성시 인스턴스로 생성할 것인지 정적으로 생성할 것인지에 대한 판단 기준은 ‘공용으로 사용하느냐 아니냐’임
> -   Static 키워드 없이 생성한다면 자동으로 인스턴스로 생성되며, 정적으로 생성하려면 필드와 메소드 선언 시 static이라는 키워드를 추가적으로 붙여야 함

> 23. final
>
> -   Final 필드의 초기값을 줄 수 있는 2가지 방법
>     -> 필드 선언 시 주기 / 생성자를 통해 주기
>     -   Final 객체
>         -> 객체 변수에 final 선언하면 그 변수에 다른 참조 값을 지정할 수 없음 (한 번 생성된 final 객체는 같은 타입으로 재생성이 불가능, 객체 자체는 변경 불가능하지만 객체 내부 변수는 변경 가능함)
>     -   Final 클래스
>         -> 클래스에 final을 사용하게 되면 그 클래스는 최종 상태가 되어 더 이상 상속이 불가능 (final 클래스여도 필드는 setter 함수를 통해 변경 가능)
>     -   Final 메서드
>         -> 메서드에 final을 사용하게 되면 상속받은 클래스에서 부모의 final 메서드를 재정의할 수 없음 (이를 이용해서 주로 자신이 만든 메서드를 변경할 수 없게 하고싶을 때 사용되며 시스템의 코어 부분에서 변경을 원치 않는 메서드에 많이 구현되어 있음)
> -   메서드의 인자 값에 final을 사용하는 경우 또한 final 필드와 마찬가지로 인자 값의 변경이 불가능 함

### 객체의 생성

> 24. new
>
> -   객체를 Heap 메모리 영역에 메모리 공간을 할당해주고 메모리 주소를 반환한 후 생성자를 실행시켜줌
> -   New 연산자로 생성된 객체는 똑같은 값을 가졌더라도 서로 다른 메모리를 할당하기 때문에 서로 다른 객체로 분류됨

### 객체의 지정

> 25. This
>
> -   인스턴스의 자기 자신을 의미
> -   자기 자신의 메모리를 가리킴
> -   생성자에서 다른 생성자를 호출할 경우 사용
> -   인스턴스 자신의 주소를 반환할 때 사용
> -   메서드(함수) 혹은 생성자에서 쓰는 파라미터(매개변수)가 클래스의 멤버 변수명과 동일할 때 둘을 구분하기 위해 사용

> 26. Super
>
> -   상속받은 부모 클래스의 변수명이나 클래스 변수를 참조할 때 사용함
> -   부모 클래스 생성자를 호출함

### 객체의 타입

> 27. Instanceof
>
> -   객체의 클래스를 알아내는 연산자
> -   객체가 어떤 클래스인지, 어떤 클래스를 상속받았는지 확인하는데 사용하는 연산자
> -   참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
> -   추상 클래스를 사용하다 보면 많은 양의 서브 클래스를 다뤄야 하는 경우가 있는데, 그럴 때 사용하면 어떤 서브 클래스 객체를 사용하는지 알아낼 수 있음
> -   좌변의 변수가 가리키는 객체의 클래스가 오른쪽과 같은 클래스인지 여부를 확인할 수 있음

###### 용어 모음

CBD, Instance, OS, Heap Area, Cache memory, Register, API, API의 I(interface), xxx’let’ : life cycle이 있도록 프로그램을 짜주는 것 (ex. Applet, Midlet, Servlet etc.), RML, RMI (method invocation), CORBA, JDBC, RPC, Byte code, multi threads, event handling for GUI,interfaces (API 에서 왜 interface라는 단어를 썼을지 과제 -> 다른 사람이 짠 코드의 함수 호출을 위함), constructor(생성자)

#### Java Keyword (과제 제출해야할 용어들, 키워드 나열 말고 class를 가운데 두고 상하좌우로 정리)

| 위치 |                                              java keyword                                              |
| :--: | :----------------------------------------------------------------------------------------------------: |
|  상  |                        package, import (객체랑 관계 없이 프로그램을 위한 것들)                         |
|  하  | 상속의 조건 : static, final / 객체의 생성 : new / 객체의 지칭 : this, super / 객체의 타입 : instanceof |
| 중심 |                                     객체의 구성 : class, interface                                     |
|  좌  |                             객체의 접근 기준 : public, private, protected                              |
|  우  |                                       상속 : extends, implements                                       |

#### Java 내의 예외처리 관련 keywords

> 1.  try
>
> -   한 번은 예외가 발생할 수 있는 함수를 실행함
>
> 2.  catch
>
> -   함수 실행 중 예외가 발생되면 실행함
>
> 3.  finally
>
> -   필요 시 무조건 실행함
>
> 4.  throws(Exception type)
>
> -   메서드에서 처리해야 할 하나 이상의 예외를 메서드를 호출한 곳(상위메서드)으로 던짐
> -   예외를 없애지는 못 하고 그저 호출한 곳으로 예외를 전달하기만 함
> -   예외를 전달받은 메서드는 다시 예외 처리 책임이 발생
> -   주로 개발자가 직접 정의하는 예외를 발생시키고 싶은 경우 사용
>
> 5.  throw
>
> -   예외를 강제로 발생시킨 후 상위 블럭이나 catch문으로 예외를 던짐

---

# 용어 정리 두 번째 과제

1. ECA
2. Method Invocation (Message passing)
3. Activation Record : 프로그래밍 동작 원리 (stack 활용)
4. Call-by-value / Call-by-reference
5. 지역 변수 ?

call-by-value / call-by-reference 차이 구별, Lab2-7 실습하고 설명까지 달기
